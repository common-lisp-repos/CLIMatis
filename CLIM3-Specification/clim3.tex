\documentclass{report}

\def\Tiny{ \font\Tinyfont = cmb10 at 3pt \relax  \Tinyfont}
\def\cl{Common Lisp}
\def\clim{\textsf{CL{\i}\kern-0.53em\raise1.2ex\hbox{\Tiny 3}M}}
\def\climtwo{CLIM\thinspace{\small II}}
\def\clos{CLOS}
\def\lisp{Lisp}
\def\zone{zone}
\def\code#1{\texttt{#1}}

\def\inputfig#1{\input #1}
\def\inputtex#1{\input #1}
\def\inputal#1{\input #1}

\inputtex{logos.tex}
\inputtex{refmacros.tex}
\inputtex{other-macros.tex}

\setlength{\parskip}{0.3cm}
\setlength{\parindent}{0cm}

\title{\clim{}\\ A new interface manager for\\ \cl{}}
\author{Robert Strandh}


\begin{document}

\maketitle

\tableofcontents

\chapter{Preliminaries}

This document is work in progress.  It contains some ideas about the
successor of \climtwo{}, the Common Lisp Interface Manager.  \climtwo{} is in
many respects a very good specification.  We believe, however, that
the reason for many design decisions were related to limitations of
the performance of computers at the time the specification was
written; limitations that are much less severe these days.  

We have attempted to simplify many aspects of the \climtwo{}
specification, often according to the \emph{issues} that are listed in
it.  One major such simplification is that we have merged three
concepts: \emph{sheet}, \emph{output-record} and \emph{design} (to
some degree). 

\chapter{Introduction}

All terminology is preliminary.


\chapter{Zones}

At the lowest level of abstraction, \clim{} uses a \emph{canvas} which
is an axis-aligned rectangular area of opaque \emph{pixels} supplied by
the underlying windowing system.  Drawing on this canvas means taking
some arbitrary subset of pixels on it, and modifying their color
values in some way.  The result thus depends not only on what was
drawn, but also what was there before.  The \emph{order} in which
drawings are made is thus important.  The canvas uses integer
coordinates.

Applications do not draw directly to the canvas, and in fact \clim{}
does not have any representation of the canvas.  Instead,
\clim{} manages a \emph{hierarchy} of \emph{zones}.  A zone is an
axis-aligned rectangular area.  Each zone manages its own abstract
\emph{drawing plane} which is a potentially infinite plane with its
origin in the upper-left corner of the zone.  The position and size
of a zone are defined with integer coordinates, and the position is
relative to its parent zone.  The effect of drawing a zone is
\emph{clipped} by its parent zone, i.e., a request to draw a zone
is accompanied by a clipping region, and zones are not allowed to
draw outside this region, because if they did, the result would be
incorrect. 

When a hierarchy is attached to a \emph{port} (representing a display
server), the \emph{backend} takes this hierarchy of zones and
\emph{realizes} each zone in the hierarchy in some device-specific
way.  Some backends may choose to create a window for each zone, and
some others may chose to create a single window for the top zone. 

Zones are either \emph{atomic} or \emph{compound}.  An atomic zone
represents an elementary graphics object such as a line, a rectangle,
an ellipse, or an image.  Zones for managing input are also atomic
zones.  A compound zone contains a bunch of children organized in a
way that depends on the specific compound zone.  It could be a \cl{}
list, a \cl{} two-dimensional array, or something else.  Each zone has
a \emph{position}, a \emph{size}, and a \emph{depth}.  The position
and the depth represent information relating to the \emph{parent} of
the zone.  The depths of the children of a compound zone determine the
order in which children are traversed for things like drawing.

In terms of zone composition operations, zones on the same level of
the hierarchy are usually composed using the \emph{compose-over}
operation, in the order determined by the depth, and for a compound
zone, the result of the composition of the children is composed with
the parent, where the parent acts as a clipping region for the
children.  In other words, rendering a composite zone is a matter of
rendering the children in order of decreasing depth, except that the
output is clipped by the parent. 

Most zones are not created with exact sizes, because the exact size of
a zone may depend on the backend.  This is in particular the case for
a \emph{text zone} the size of which depends on the \emph{font} used
to render it, and the font is specific to each backend.  Instead, each
zone has a horizontal and a vertical \emph{sprawl}.  A sprawl is an
object that represents the \emph{desired} preferred, minimum, and
maximum sizes of a zone.  The are just \emph{desired} because each
zone type must be able to handle being assigned any size as decided by
the parent zone or the backend.  Some zones have sprawls assigned at
creation time.  Others, such as many compound layout zones, compute
their sprawls as a function of the sprawls of their children.  Yet
others, in particular \emph{text} compute their sprawls by consulting
the port that it is connected to.

Applications can manipulate the zone hierarchy in several different
ways:  

\begin{itemize}
\item They may explicitly insert or delete zones.  In this case
  \clim{} may try to minimize the areas of the canvas that need to be
  redrawn by re-using pixel colors that are known to be the same as
  last time around the command loop.

\item Simpler application might generate new zone hierarchies every
  time around the command loop.  In this case, \clim{} will have to
  redraw the entire contents of the zone.

\item An application may produce a new collection of children for some
  compound zone each iteration of the command loop such that some or
  all of the new zones are \emph{the same} as the existing ones.
  \clim{} may compare the new collection to the old one, and again
  minimize redrawing.

\item An application may \emph{move} a zone.  Since the canvas uses
  integer coordinates, \clim{} might then be able to move the pixels
  without requiring the application to generate new output.  This is a
  particularly important optimization when \emph{scrolling} is
  required.  Moving a zone is allowed only when the zone does not have
  a parent, or when the parent is a layout zone that allows its
  children to determine their own positions. 
\end{itemize}

\section{Graphic zones}
\label{sec-zones-graphic}

A \emph{graphic zone} is an atomic zone.  When such a zone is
\emph{painted}, some subset of the pixels inside it may have their
color values altered.

Graphic zones are \emph{immutable}, so as to guarantee that the result
of painting one is the same each time it is painted.  If an
application wants to alter the behavior of some graphics zone, say its
color, then the only way is to stick it inside a compound zone (the
simplest one is the \code{wrap} zone \seesec{sec-zones-layout-wrap})
and replace it with a new one with the altered behavior.%
\footnote{The reason for graphic zone to be immutable is so that
  \clim{} can detect a change by comparing two such zones using
  \code{eq}.  When such a comparison yields \emph{true} and if the
  zone has the same size as before, then \clim{} uses this information
  to decide that the result of painting the zone will be the same as
  last time.}

\subsection{Opaque}
\label{sec-zones-graphic-opaque}

The simplest graphic zone is the \code{opaque} zone.  It ignores the
color values of the existing pixels and paints the entire zone with
some fixed color value that was given when the zone was created.
Since graphic zones are immutable, it is not possible to change this
color value.  The \emph{sprawls} of an opaque zone are the same as
those of a \code{sponge} \seesec{sec-zones-layout-sponge}, i.e., it
is very elastic so that it can take on any size. 

\subsection{Masked}
\label{sec-zones-graphic-masked}

The \code{masked} zone uses a \emph{color} and a \emph{mask} to alter
the pixels inside it when painted.  A mask is a 2-dimensional array of
opacity values (also known as \emph{alpha} values).  The zone is
painted using the \emph{compose over} color composition operation.
The minimum, preferred, and maximum sizes for a masked zone are the
same as the sizes for the mask.  The mask is considered to be
positioned so that the upper-left corner of the mask coincides with
the upper-left corner of the zone.  If the zone is smaller than the
mask in some dimension, then the output is clipped by the zone as
usual.  If the zone is larger than the mask in some dimension, the
pixels outside the mask are considered completely transparent. 

\subsection{Translucent}
\label{sec-zones-graphic-translucent}

The \code{translucent} zone uses a \emph{color} and an \emph{opacity}
value (also known as an \emph{alpha} value) to alter the pixels inside
it when painted.  Since graphic zones are immutable, it is not
possible to change the color or the opacity value.  The \emph{sprawls}
of a translucent zone are the same as those of a \code{sponge}
\seesec{sec-zones-layout-sponge}, i.e., it is very elastic so that it
can take on any size.

\subsection{Image}
\label{sec-zones-graphic-image}

The \code{image} zone uses an \emph{image} to alter the pixels inside
it when painted.  An image is a 2-dimensional array of \emph{pixels}.
A pixel is a color and an opacity value.  The zone is painted using
the \emph{compose over} color composition operation.  The minimum,
preferred, and maximum sizes for an image zone are the same as the
sizes for the image.  The image is considered to be positioned so that
the upper-left corner of the image coincides with the upper-left
corner of the zone.  If the zone is smaller than the image in some
dimension, then the output is clipped by the zone as usual.  If the
zone is larger than the image in some dimension, the pixels outside
the image are considered completely transparent.

\section{Layout zones}
\label{sec-zones-layout}

A \emph{layout zone} is a zone that may have some \emph{children} that
are also zones.  Each type of layout zone is characterized by:

\begin{itemize}
\item the method it uses for combining the sprawls of its children
  into its own vertical and horizontal sprawls, and
\item the method it uses for determining the size and relative
  position of each child, given the size that is imposed on it. 
\end{itemize}

\subsection{Wrap}
\label{sec-zones-layout-wrap}

The \code{wrap} zone is a zone that has either no children or a single
child.  

If the \code{wrap} zone has no child, it behaves in the same way as
the \code{sponge} zone. \seesec{sec-zones-layout-sponge} If it has a
child, then it takes on the sprawls of that child.

If the \code{wrap} zone has a child, then it positions that child at
its own upper-left corner, and it imposes its own vertical and
horizontal size on the child.

The wrap zone is useful as a place holder in the zone hierarchy for
places that are altered in some way by an application.  For example,
if an application wants to change the background color of a gadget,
perhaps as a result of some pointer motion, then the background color
of the gadget would typically be an \code{opaque} zone
\seesec{sec-zones-graphic-opaque} contained inside a \code{wrap}
zone.  To alter the color, the application would then replace the
child of the \code{wrap} zone by a different \code{opaque} zone having
the desired color.

\subsection{Sponge}
\label{sec-zones-layout-sponge}

The \code{sponge} zone is a zone that has either no children or a
single child.  

It ignores the sprawls of its child (if any) and imposes its own.
Each imposed sprawl has zero minimum and preferred size and infinite
maximum size.

If the \code{sponge} zone has a child, then it positions that child at
its own upper-left corner, and it imposes its own vertical and
horizontal size on the child.

\subsection{Vsponge}
\label{sec-zones-layout-vsponge}

The \code{vsponge} zone is a zone that has either no children or a
single child.  If it has no child, it behaves the same way as the
\code{sponge} zone. \seesec{sec-zones-layout-sponge}  If it has a
child, it copies the horizontal sprawl of the child, and it ignores
the vertical sprawl of its child and imposes its own with zero minimum
and preferred size and infinite maximum size.

If the \code{vsponge} zone has a child, then it positions that child
at its own upper-left corner, and it imposes its own vertical and
horizontal size on the child.

\subsection{Hsponge}
\label{sec-zones-layout-hsponge}

The \code{hsponge} zone is a zone that has either no children or a single
child.  If it has no child, it behaves the same way as the
\code{sponge} zone. \seesec{sec-zones-layout-sponge}  If it has a
child, it copies the vertical sprawl of the child, and it ignores
the horizontal sprawl of its child and imposes its own with zero minimum
and preferred size and infinite maximum size.

If the \code{hsponge} zone has a child, then it positions that child
at its own upper-left corner, and it imposes its own vertical and
horizontal size on the child.

\subsection{Brick}
\label{sec-zones-layout-brick}

The \code{brick} zone is a zone that has either no children or a
single child.  It ignores the sprawls of its child (if it has one) and
imposes its own.  The minimum, preferred, and maximum sizes are all
the same for the vertical sprawl, and all the same for the horizontal
sprawl.  Those sizes are determined when the brick is created.

If the \code{brick} zone has a child, then it positions that child at
its own upper-left corner, and it imposes its own vertical and
horizontal size on the child.

\subsection{Vbrick}
\label{sec-zones-layout-vbrick}

The \code{vbrick} zone is a zone that has either no children or a
single child.  If it has no child, it behaves the same way as the
\code{brick} zone. \seesec{sec-zones-layout-brick}  If it has a
child, it copies the horizontal sprawl of the child, and it ignores
the vertical sprawl of its child and imposes its own with identical
minimum, preferred, and maximum sizes, determined at creation time.

If the \code{vbrick} zone has a child, then it positions that child at
its own upper-left corner, and it imposes its own vertical and
horizontal size on the child.

\subsection{Hbrick}
\label{sec-zones-layout-hbrick}

The \code{hbrick} zone is a zone that has either no children or a
single child.  If it has no child, it behaves the same way as the
\code{brick} zone. \seesec{sec-zones-layout-brick}  If it has a
child, it copies the vertical sprawl of the child, and it ignores
the horizontal sprawl of its child and imposes its own with identical
minimum, preferred, and maximum sizes, determined at creation time.

If the \code{hbrick} zone has a child, then it positions that child at
its own upper-left corner, and it imposes its own vertical and
horizontal size on the child.

\subsection{Vbox}
\label{sec-zones-layout-vbox}

The \code{vbox} zone is a zone that arranges its children in a
vertical box.  It can have an arbitrary number of children.

The vertical sprawl of the \code{vbox} is computed by combining the
vertical sprawls of its children in \emph{series} and the horizontal
sprawl of the \code{vbox} is computed by combining the horizontal
sprawls of its children in \emph{parallel}.
\seesec{sec-zone-protocols-geometry-sprawl}

The vertical size imposed on the \code{vbox} is distributed according
to the method described in \refSec{sec-zone-protocols-geometry-sprawl}
for children combined in series.  The horizontal size imposed on the
\code{vbox} is imposed as is on each child. 

\subsection{Hbox}
\label{sec-zones-layout-hbox}

The \code{hbox} zone is a zone that arranges its children in a
horizontal box.  It can have an arbitrary number of children.

The horizontal sprawl of the \code{hbox} is computed by combining the
horizontal sprawls of its children in \emph{series} and the vertical
sprawl of the \code{hbox} is computed by combining the vertical
sprawls of its children in \emph{parallel}.
\seesec{sec-zone-protocols-geometry-sprawl}

The horizontal size imposed on the \code{hbox} is distributed according
to the method described in \refSec{sec-zone-protocols-geometry-sprawl}
for children combined in series.  The vertical size imposed on the
\code{hbox} is imposed as is on each child. 

\subsection{Grid}
\label{sec-zones-layout-grid}

The \code{grid} zone is a zone that arranges its children in a
two-dimensional grid.  

To compute the vertical sprawl of the \code{grid}, the vertical
sprawls of the children of each \emph{row} are first combined in
\emph{parallel}, and the resulting sprawls for each row are then
combined in \emph{series}.  

To compute the horizontal sprawl of the \code{grid}, the horizontal
sprawls of the children of each \emph{column} are first combined in
\emph{parallel}, and the resulting sprawls for each column are then
combined in \emph{series}.
\seesec{sec-zone-protocols-geometry-sprawl}

The vertical size imposed on the \code{grid} is distributed to its
rows according to the method described in
\refSec{sec-zone-protocols-geometry-sprawl} for children combined in
series, and the resulting vertical size for each row is imposed as is
on each child of the row.

The horizontal size imposed on the \code{grid} is distributed to its
columns according to the method described in
\refSec{sec-zone-protocols-geometry-sprawl} for children combined in
series, and the resulting horizontal size for each column is imposed
as is on each child of the row.

\subsection{Pile}
\label{sec-zones-layout-pile}

The \code{pile} zone is a zone that arranges its children on top of
each other.

To compute the vertical sprawl of the \code{pile}, the vertical
sprawls of its children are combined in \emph{parallel}, and to
compute the horizontal sprawl of the \code{pile}, the horizontal
sprawls of its children are also combined in \emph{parallel}. 


The vertical and the horizontal sizes imposed on the \code{pile}
are imposed as is on each child.

\section{Input zones}
\label{sec-zones-input}

An \emph{input zone} is a zone that reacts to input from the user.
All input zones behave like the \code{sponge} zone when it comes to
the vertical and horizontal sprawl.  To obtain an input area of a
particular size, the input zone must be combined with one or more
\emph{layout zones} that will have the desired size.
\seesec{sec-zones-layout} 

All input zones are \emph{atomic} in that they can not have any child
zones.

\subsection{Visit}
\label{sec-zones-input-visit}

The \code{visit} zone is an input zone that contains two
\emph{handlers}, one that is called whenever the pointer enters the
zone, and another that is called whenever the pointer leaves the zone.
The handlers are called with the zone as an argument.

The \code{visit} zone also contains a function that is used to
determine more precisely whether the pointer is considered to be
inside the zone.  This function is given the relative horizontal and
vertical position of the pointer, and returns a generalized Boolean.
When the value is \emph{true}, the pointer is considered to be
inside.  By default, this function returns \texttt{true} for all
arguments. 

\chapter{Command loop}

\clim{} maintains a \emph{command loop} as follows:

\begin{itemize}
\item Acquire a \emph{command object}.
\item Acquire the arguments of the command object.
\item Execute the command object on the arguments.
\item Call \code{redisplay} on the top zone.  The result of calling
  \code{redisplay} might be a new zone or the same zone, modified
  or unchanged.  The behavior of redisplay on a particular zone
  depends on the exact subclass of the zone.
\item Update the visible area of the screen according to the new
  zone hierarchy.
\end{itemize}

\chapter{Zone protocols}

\section{Purpose}

The purpose of the zone protocols is twofold:

\begin{itemize}
\item The main purpose is to make certain operations simple and
  transparent to applications.  See below for details.
\item The secondary purpose is to optimize rendering so that even for
  very large data sets, the response time is reasonable.
\end{itemize}

Applications should be able to manipulate both connected and
disconnected zone hierarchies in a painless way.  Operations available
to an application are:

\begin{itemize}
\item An application should be able to move a zone by setting its
  horizontal and vertical positions, provided it is not the child of a
  layout zone that specifically disallows this operation.  The result
  of the operation should be immediately visible after the next
  iteration of the event loop.
\item An application should be able to modify the depth of a zone,
  provided it is not the child of a layout zone that specifically
  disallows this operation.  Again, the result of the operation should
  be immediately visible after the next iteration of the command
  loop. 
\item An application should be able to change the children of a
  compound zone.  This is the main operation used to manipulate the
  zone hierarchy.  
\end{itemize}

Notice that the effects of the modifications are synchronized with the
event loop, and that the event loop is responsible for the ultimate
rendering of the zone hierarchy.  Therefore, an application can make
multiple changes to the zone hierarchy as a result of a single event,
and only the final result of those changes will be rendered.  

Let us examine the consequences of these operations in greater
detail. 

\subsection{Moving a zone}

If the zone is the root zone, then we might want to ask the display
server to move the corresponding window. 

If the zone is the child of bboard zone, then we need to render it in
a different place next time. 

If the zone is the child of a scroller zone, the scrollbar will have
to be rendered differently next time. 

If the zone if part of a layout zone that imposes positions of the
child, then an error will be signaled. 

\subsection{Modifying the depth of a zone}

If the zone is a root zone, we might ask the window manager to raise
or bury the corresponding window, but we might do nothing. 

Otherwise, the sibling zones will be rendered in a different order
next time.

\subsection{Changing the children of a zone}

If the zone is a bboard zone, new children must have valid sprawls so
that we can compute their natural sizes before rendering

If the zone is a scroller zone, we must make sure the child has a
valid sprawl so that we can compute its natural size before rendering.

If the zone is the child of a layout zone that computes its sprawls from
the sprawls of its children, then the parent must have its sprawls
invalidated, so that they are recomputed next time it is rendered.
This invalidation must propagate up the hierarchy until a zone is
reached that does not take child sprawls into account. 

\section{Zone geometry protocol}

\subsection{Sprawl}
\label{sec-zone-protocols-geometry-sprawl}

The desired dimensions of a zone are expressed in the form of objects
of type \emph{sprawl}.  A sprawl is an object with three components:
the \emph{minimum size}, the \emph{preferred size} and the \emph{maximum
  size}.  Each zone has one horizontal sprawl and one vertical sprawl.

The three components of a sprawl are interpreted as \emph{desired}, so
that the minimum size is really the \emph{desired minimum size}, the
preferred size is really the \emph{desired preferred size}, and the
maximum size is really the \emph{desired maximum size}.  Every zone
must be prepared to take on any size that is imposed on it by the
parent zone or by the display server.  \clim{} will try as much as
possible to honor the desired sizes, but sometimes it is not possible,
so some other size will be chosen.

The minimum and preferred sizes of a sprawl are non-negative
integers.  The maximum size is either a non-negative integer, or
\texttt{NIL}, indicating that the zone has no desired maximum size. 
The preferred size is greater than or equal to the minimum size and
the maximum size is either \texttt{NIL} or it is greater than or equal
to the preferred size. 

\subsubsection{Combining sprawls}

Sprawls can be combined either in \emph{series} (like the vertical
sprawls of the zones inside a vbox), or in \emph{parallel} (like the
horizontal sprawls of a the zones inside a vbox).  

When combined in series, the different components are then summed up
individually so that the minimum size is the sum of each individual
minimum size, the preferred size is the sum of each individual
preferred size, and the maximum size is the sum of each individual
maximum size, or \texttt{NIL} if any individual maximum size is
\texttt{NIL}.

Combining sprawls in parallel is a more difficult operation.  The
basic idea is that the minimum size is computed as the maximum of each
individual minimum size, the preferred size is computed as the average
of the preferred sizes, and the maximum size is computed as the
minimum of each individual maximum size, or \texttt{NIL} if all of the
individual maximum sizes are \texttt{NIL}.  However, there are many
situations where this method is not possible, perhaps because the
minimum size of one individual sprawl is greater than the maximum size
of another.  In that case, some compromise is made, the details of
which is not terribly important.  Applications should avoid situations
like that though. 

\subsubsection{Distributing space among combined sprawls}

When some parent zone imposes the size of child zones whose sprawls
have been combined in series, the imposed size of the parent must be
distributed among the individual child zones.  In some situations,
this is easy, such as when the imposed size of the parent is greater
than the sum of the preferred sizes of its children, and some maximum
child size is \texttt{NIL}.  In that case, the difference between the
imposed size of the parent and the sum of the preferred sizes of the
children is distributed evenly among the children having a
\texttt{NIL} maximum size.

FIXME: say more....

When some parent zone imposes the size of child zones whose sprawls
have been combined in parallel, the same size is imposed on each child
zone.

\subsection{Generic functions}

\subsubsection{Generic function \texttt{hpos}}

Return the current horizontal position of the zone relative to its
parent.  

If the zone is the root zone and it is connected to some display
server, then depending on the display server, this value may or
may not reflect the position of the corresponding top-level
window on the display. 

\subsubsection{Generic function \texttt{(setf hpos)}}

Set the current horizontal position of the zone relative to its
parent.  

Calling this function is the normal way of setting the position of
a zone that is the child of a layout zone that does not impose the
position of its children, such as a bboard zone or a scroller
zone.

Setting the position of a zone may not have the effect that an
application expects.  If the zone is the child of a layout zone
that imposes the position of its children, then the change will be
undone before the next time around the event loop, so that no
visible effect can be detected.  

If the zone is the root zone and it is connected to some display
server, then depending on the display server, this value may or
may not affect the position of the corresponding top-level window
on the display.

Calling this function triggers the geometry-change protocol,
informing the parent that a change has taken place.  

\subsubsection{Generic function \texttt{set-hpos}}

Set the current horizontal position of the zone relative to its
parent, without triggering the geometry-change protocol.

This function is similar to \texttt{(setf hpos)}, with the difference
that it does not trigger the geometry-change protocol.  It is used
exclusively by internal protocols to avoid infinite recursions when a
parent needs to set the position of a child as a result of some
previous change.

\subsubsection{Generic function \texttt{vpos}}

Return the current vertical position of the zone relative to its
parent.  

If the zone is the root zone and it is connected to some display
server, then depending on the display server, this value may or
may not reflect the position of the corresponding top-level window
on the display.

\subsubsection{Generic function \texttt{(setf vpos)}}

Set the current vertical position of the zone relative to its
parent.

Calling this function is the normal way of setting the position of
a zone that is the child of a layout zone that does not impose the
position of its children, such as a bboard zone or a scroller
zone.

Setting the position of a zone may not have the effect that an
application expects.  If the zone is the child of a layout zone
that imposes the position of its children, then the change will be
undone before the next time around the event loop, so that no
visible effect can be detected.  

If the zone is the root zone and it is connected to some display
server, then depending on the display server, this value may or
may not affect the position of the corresponding top-level window
on the display.

Calling this function triggers the geometry-change protocol,
informing the parent that a change has taken place.  

\subsubsection{Generic function \texttt{set-vpos}}

Set the current vertical position of the zone relative to its
parent, without triggering the geometry-change protocol.

This function is similar to \texttt{(setf vpos)}, with the difference
that it does not trigger the geometry-change protocol.  It is used
exclusively by internal protocols to avoid infinite recursions when a
parent needs to set the position of a child as a result of some
previous change.

\subsubsection{Generic function \texttt{width}}

Return the current width of the zone.  

If the zone is the root zone and it is connected to some display
server, then depending on the display server, this value may or
may not reflect the width of the corresponding top-level window.

\subsubsection{Generic function \texttt{(setf width)}}

Set the current width of the zone.

Calling this function is the normal way of setting the width of a
zone that is the child of a layout zone that does not impose the
size of its children, such as a bboard zone or a scroller zone.

Setting the position of a zone may not have the effect that an
application expects.  If the zone is the child of a layout zone
that imposes the size of its children, then the change will be
undone before the next time around the event loop, so that no
visible effect can be detected.

If the zone is the root zone and it is connected to some display
server, then depending on the display server, this value may or
may not affect the width of the corresponding top-level window
on the display.

Calling this function triggers the geometry-change protocol,
informing the parent that a change has taken place.  

\subsubsection{Generic function \texttt{set-width}}

Set the current width of the zone relative to its parent, without
triggering the geometry-change protocol.

This function is similar to \texttt{(setf width)}, with the difference
that it does not trigger the geometry-change protocol.  It is used
exclusively by internal protocols to avoid infinite recursions when a
parent needs to set the width of a child as a result of some previous
change.

\subsubsection{Generic function \texttt{height}}

Return the current height of the zone.

If the zone is the root zone and it is connected to some display
server, then depending on the display server, this value may or
may not reflect the height of the corresponding top-level window.

\subsubsection{Generic function \texttt{(setf height)}}

Set the current height of the zone.

Calling this function is the normal way of setting the height of a
zone that is the child of a layout zone that does not impose the
size of its children, such as a bboard zone or a scroller zone.

Setting the position of a zone may not have the effect that an
application expects.  If the zone is the child of a layout zone
that imposes the size of its children, then the change will be
undone before the next time around the event loop, so that no
visible effect can be detected.

If the zone is the root zone and it is connected to some display
server, then depending on the display server, this value may or
may not affect the height of the corresponding top-level window on
the display.

Calling this function triggers the geometry-change protocol,
informing the parent that a change has taken place.

\subsubsection{Generic function \texttt{set-height}}

Set the current height of the zone relative to its parent, without
triggering the geometry-change protocol.

This function is similar to \texttt{(setf height)}, with the
difference that it does not trigger the geometry-change protocol.  It
is used exclusively by internal protocols to avoid infinite recursions
when a parent needs to set the height of a child as a result of some
previous change.

\subsubsection{Generic function \texttt{depth}}


\subsubsection{Generic function \texttt{(setf depth)}}

\subsection{Classes}

\subsubsection{Class \texttt{zone}}

The class \texttt{zone} is the base class for all zones. 


\section{Zone genealogy protocol}

\subsection{Generic functions}

\subsubsection{Generic function \texttt{parent}}

Return the current parent of the zone. 

The parent may be another zone, in which case the zone is a child of
that zone, or it may be a client (typically a port), in which case the
zone is the root zone of a hierarchy connected to that client, or it
may be nil, in which case, this zone is the root zone of a hierarchy
not currently connected to any client.

\subsubsection{Generic function \texttt{(setf parent)}}

Set the parent of a zone.

This generic function is part of the internal zone protocols.  It
should not be used directly by applications.  It is called indirectly
as a result of connecting the zone to a client, or as a result of
adding or removing the zone as a child of some other zone by calling
\texttt{(setf children)}.

\subsubsection{Generic function \texttt{children}}

This generic function returns the children of a compound zone.  The
representation of the return value depends on the subclass of
\texttt{compound-zone}.  It could be a list, a vector, a 2-D array, or
something else.

\subsubsection{Generic function \texttt{(setf children)}}

This generic function sets the children of a compound zone.  The
acceptable representation of the children depends on the subclass of
\texttt{compound-zone}.  It could be a list, a vector, a 2-D array, or
something else.  However, the representation is consistent with what
is returned by the \texttt{children} generic function, so that if a list is
returned by that generic function, then a list is acceptable to this
one too.  In particular, it is acceptable to call this function with
the exact same value as was return by a call to \texttt{children}.

There are \texttt{:around} methods on this function (see below).  One
is specialized for \texttt{at-most-one-child-mixin}, and the other for
\texttt{any-number-of-children-mixin}, both subclasses of
\texttt{compound-zone}.  These \texttt{:around} methods always call
the primary methods, but they also do some extra work such as error
checking, setting the parent of every new child, removing the parent
of every removed child, and client notification.  The \texttt{:around}
method calls \texttt{children}, which has as a consequence that in
order to use \texttt{(setf children)} the corresponding slot must be
bound.

There is one \texttt{:after} method specialized for
\texttt{compound-zone} that calls

\subsubsection{generic function \texttt{map-over-children}}

the first argument is a function of a single argument.  the second
argument is a zone.  this function calls the function given as the
first argument on each child of the zone given as a second argument.  

\subsubsection{generic function \texttt{map-over-children-top-to-bottom}}

the first argument is a function of a single argument.  the second
argument is a zone.  this function calls the function given as the
first argument on each child of the zone given as a second argument.  

\subsubsection{generic function \texttt{map-over-children-bottom-to-top}}

The first argument is a function of a single argument.  The second
argument is a zone.  This function calls the function given as the
first argument on each child of the zone given as a second argument.  

\subsection{Classes}

\subsubsection{Class \texttt{atomic-zone}}

\subsubsection{Class \texttt{compound-zone}}

\subsubsection{Class \texttt{compound-simple-zone}}

\subsubsection{Class \texttt{compound-sequence-zone}}

\subsubsection{Class \texttt{compound-matrix-zone}}

\subsubsection{Class \texttt{at-most-one-child-mixin}}

\subsubsection{Class \texttt{any-number-of-children-mixin}}


\section{Sprawls change protocol}

FIXME: this section no longer reflects recent changes, so it needs
updating.

The sprawls change protocol is divided into four functions for maximum
flexibility to client code, three of them generic, and one is an
ordinary function.

\subsection{Generic functions and methods}

\subsubsection{Generic function \texttt{sprawls-valid-p}}
\label{generic-function-sprawls-valid-p}

This function returns true if and only if the sprawls of the zone are
valid.  

For zones with sprawls that can not be invalidated, such as bboard
zones, scroller zones, and atomic zones with sprawls that do not depend
on a client, this function always returns \emph{true}.

The methods of this function are paired up with methods for
\texttt{mark-sprawls-invalid} so that they both use the same mechanism. 

This function should return \emph{false} after a call has been made to
\texttt{mark-sprawls-invalid}, and should return \emph{true} after a
call has been made to \texttt{compute-sprawls}.  

A method specialized for \texttt{dependent-sprawls-mixin} is supplied
that returns \emph{true} of and only if both the \texttt{vsprawl} and
the \texttt{hsprawl} of the zone are \texttt{nil}

A method specialized for \texttt{hdependent-sprawls-mixin} is supplied
that returns \emph{true} if and only if the \texttt{hsprawl} of the zone
is \texttt{nil}.

A method specialized for \texttt{vdependent-sprawls-mixin} is supplied
that returns \emph{true} if and only if the \texttt{vsprawl} of the zone
is \texttt{nil}.

A method specialized for \texttt{independent-sprawls-mixin} is supplied
that always returns \emph{true}. 

\subsubsection{Generic function \texttt{mark-sprawls-invalid}}
\label{generic-function-mark-sprawls-invalid}

This function marks the zone as having invalid sprawls.  

For zones with sprawls that can not be invalidated, such as bboard
zones, scroller zones, and atomic zones with sprawls that do not depend
on a client, this function signals an error.

Different subclasses of \texttt{zone} do this differently.  Some set
both the hsprawl and the vsprawl to \texttt{nil}.  Some others set one but
not the other.  Some may use a completely different mechanism.

The methods of this function are paired up with methods for
\texttt{sprawls-invalid-p} so that they both use the same mechanism.

A method specialized for \texttt{dependent-sprawls-mixin} is supplied
that sets both the \texttt{vsprawl} and the \texttt{hsprawl} of the zone
to \texttt{nil}

A method specialized for \texttt{hdependent-sprawls-mixin} is supplied
that sets the \texttt{hsprawl} of the zone to \texttt{nil}.

A method specialized for \texttt{vdependent-sprawls-mixin} is supplied
that sets the \texttt{vsprawl} of the zone to \texttt{nil}.

A method specialized for \texttt{independent-sprawls-mixin} is supplied
that signals an error.

\subsubsection{Generic function \texttt{notify-child-sprawls-invalid}}
\label{generic-function-notify-child-sprawls-invalid}

This function is called on a child and a parent when the sprawls of the
child are invalidated for some reason (see the function
\texttt{invalidate-sprawls}).  Methods on this generic function
specialized to parent zones (the second argument) whose sprawls depend
on the sprawls of its children must call \texttt{invalidate-sprawls} with
the parent as an argument.

Two default methods are supplied.  The first default method is
specialized on a \texttt{null} parent and it does nothing.  This way,
a zone and its parent are always valid arguments to this function,
even though the zone is disconnected.  The second default method is
specialized on a parent of type \texttt{zone} and it signals an error.
By doing it this way, we compel zones to make an explicit choice
concerning the action of this function.

Other methods are supplied for certain mixin classes.  For the mixin
classes \texttt{dependent-sprawls-mixin},
\texttt{hdependent-sprawls-mixin}, and \texttt{vdependent-sprawls-mixin},
a method is supplied that calls \texttt{invalidate-sprawls} with the
parent as an argument, as stipulated above.  For the class
\texttt{independent-sprawls-mixin}, a method is supplied that does
nothing.

\subsubsection{Function \texttt{invalidate-sprawls}}

This function is used to indicate that the sprawls of some zone are no
longer valid.  The reason for that could be that the sprawls depend on
the contents and the contents changed, or that the sprawls of the zone
depend on it being connected to some client, and it got disconnected.

If the sprawls of the zone are already invalid, i.e.,
\texttt{sprawls-valid-p} returns \emph{false}, then this function does
nothing.  Otherwise, it marks them invalid by calling
\texttt{mark-sprawls-invalid} and calls the function
\texttt{notify-child-sprawls-invalid} with the zone and its parent.

\section{Zone layout protocol}

The zone layout protocol is designed so that if the zone hierarchy is
appropriately designed, then layout can be done incrementally for good
performance. 

In any hierarchy of zones, some zones may have valid sprawls and some
zones may have invalid sprawls.  Atomic zones whose sprawls do not depend
on any client are always valid.  Atomic zones whose sprawls depend on
some client may or may not be valid.  If the zone hierarchy is not
connected to a client, they are invalid. 

A compound zone whose sprawls depend on the sprawls of its children will
have invalid sprawls if any of the children has invalid sprawls.  We
maintain this invariant by using the sprawls change protocol.  Thus, the
only case where a (compound) zone can have valid sprawls even though
some child has invalid sprawls is when that zone is such that its sprawls
are independent of the sprawls of the children.  In particular, this is
the case for scroller zones and bboard zones.

When a zone is rendered, its position and size must be known.  In
addition, we require that a zone that is rendered also have valid
sprawls, even though this is not strictly necessary.

The size and sometimes the position of a zone are set by the parent.
If the parent is a port, then the port must set these parameters
before rendering the zone.  Sometimes, when a zone is rendered, it is
possible that its children do not have the correct position and size.
For instance, if the position of a child of a hbox zone is modified by
the application, then it is likely wrong, so it must be fixed before
the hbox zone can be rendered.  Similarly, if the sprawls of a child of
a bbox zone have changed, then the natural size of that child is very
likely wrong, so it must be fixed before the bbox zone can be
rendered.

When the position or the sprawls of a zone change, we want to delay the
fixes until the parent zone must be rendered.  We do this by
maintaining a flag in compound zones that indicate whether the child
geometries are valid or not.  

\subsection{Generic functions}

\subsection{Classes}

\subsubsection{Class \texttt{dependent-sprawls-mixin}}
\subsubsection{Class \texttt{hdependent-sprawls-mixin}}
\subsubsection{Class \texttt{vdependent-sprawls-mixin}}
\subsubsection{Class \texttt{independent-sprawls-mixin}}

\section{Application frame}

An application frame is a layout zone with a small number of fixed
layouts of sub-zones (we don't call them child zones because they
are not the direct children of the application frame.  Selecting a
particular layout has the effect of creating child zones of the
application frame with positions and sizes that are determined by the
layout, and each child contains a sub-zone.

\section{Table zone}

\section{Simple application zone}

This is a zone that executes a display function each time around the
command loop in order to generate a complete hierarchy of zones.

\section{Incremental application zone}

This is a zone that is able to compare existing child zones with
new ones, and that will recursively generate zones only if a child
is new. 

\chapter{Comparing two sequences of child zones}

Initialize \code{before} and \code{after} to the beginning of the
sequence of children \emph{before} and \emph{after} redisplay
respectively.  If \code{before} is empty, then all remaining children
on \code{after} are inserted.  If \code{after} is empty, then all
remaining children on \code{before} are deleted.  Otherwise (neither
\code{before} nor \code{after} is empty), if the first zone on
\code{after} is new, then it has been inserted; advance \code{after}.
If not, the first zone  on \code{after} is also in the \code{before}
sequence.  In that case, if it is also the first element of
\code{before}, then it is either modified or unchanged according to
the flag; advance both \code{before} and \code{after}.  The last case
is when the first element of \code{after} is not the same as the first
element of \code{before}.  Then the first element of \code{before} has
been deleted; advance \code{before}. 

\part{Appendices}

This part contains material that may be deleted later, or that may be
reorganized and moved.  

\appendix
\chapter{Changes from previous version}

\section{General}

This section explains the general changes that we consider for \clim{}
compared to \climtwo{}.  Following sections will contain specific changes
with respect to particular features of \climtwo{}.

We intend to act upon one of the ``major issues'' indicated in the
\climtwo{} specification, namely a suggested merge of the \emph{sheet} and
\emph{output record} concepts.  This will greatly simplify the design
of \clim{}.

There are many issues with the \climtwo{} specification.  For
instance, what happens to an output record (which is rectangular
according to the specification) when it is in a pane that has an
arbitrary sheet transformation that does not preserve this shape?  For
\clim{} we want to clarify what happens in such situations, and
eliminate it as a part of the specification if the concept is hard or
impossible to implement. 

Several aspects of the \climtwo{} specification make it hard to
localize applications.  One such aspect is the fact that command-line
names are part of the command table, requiring a different command
table for each language.  We want to clean up such aspects so as to
prepare \clim{} for the possibility of writing applications using
different languages. 

By clarifying the semantics of \emph{zones} (which replace \climtwo{}
\emph{output records}), especially with respect to the exact time when
the effect of manipulating the hierarchy of these objects is visible,
we avoid the almost inevitably quadratic algorithms involved in
manipulating \climtwo{} output records. 

We keep the layout protocol, but clarify when it is invoked.  We
replace space requirements by vertical and horizontal elasticity
functions. 

We eliminate mirrored sheets as an explicit abstraction of \clim{} and
let each backend decide on a case-by-case basis whether a zones should
have a mirror or not.

We eliminate alignment and spacing options to the layout panes and
instead provide a zone type that is very rigid (for spacing) and a
zone type that is very elastic (for alignment).

\section{Regions and Transformations}

In \climtwo{} this is a very general concept.  We will probably keep
these, but the \clim{} equivalent of a \climtwo{} sheet (called a
\emph{zone}) will not admit arbitrary regions and transformations. 

\section{Sheets}

\section{Commands and command tables}

\section{Internationalization}

Define a classes for country, language, printing of numbers, units,
etc, and locale classes that inherit from subclasses of those.

\section{Text styles}

We keep the concept of text styles, but we may remove the concept of
merging text styles.  We add the possibility of naming font families. 
We will specify that text-style-ascent, text-style-descent,
text-style-height, and text-style-width may only be called as part of
the layout protocol, because they are only defined when the zone is
attached to a port. 

\section{Layout protocol}

We guarantee that the layout protocol will only be run when the zone
hierarchy is attached to a port.  Thus, when a text zone is asked to
provide space requirements, then it is safe for it to ask the size of
the text, because the text style then has a mapping to a device font. 

\chapter{Optimal redrawing}

\section{Introduction}

The purpose of optimal redrawing is not mainly to touch as few pixels
as possible in the visible area of the screen, even though it can do
that as well.  Instead, the purpose is to simplify applications by
having \clim{} manage a very large number of zones, most of which
are invisible at any point in time.  Imagine for instance a word
processor or an editor for music scores.  Such an application might
produce hundreds of pages of output.  Instead of leaving the burden to
the application writer to determine what part is visible, and how
large the scroll bar should be, it would be good if the application
can produce the entire output, and let \clim{} deal with scrolling and
incremental modifications to the output.  

Such an application might be written to produce a hierarchy of
zones.  At a high level, each page might be a zone.  Each such
page can contain paragraphs or, in the case of a score editor,
\emph{systems}, then lines, words, and perhaps individual characters.
This output is visible through a small viewport that might cover a
single page, or at most a few pages.  The main purpose of the
algorithm presented here is to avoid invoking code to draw parts of
the output that are currently invisible and parts that have not changed
since the previous time.  For instance, after a single modification of
a page of text, most paragraphs might be intact.  The algorithm
described here is able to avoid redrawing such paragraphs. 

In other words, the application writer does not explicitly manage
visibility, and can write the application as if every part of the
output is visible.

The algorithm makes two passes over a hierarchy of zones, the first
one from top to bottom, and the second one from bottom to top.  For
this reason the sequence of zones is probably best represented as a
doubly-linked list.

In the first pass, a region to be redrawn is computed.  This region
starts out as empty and is potentially added to for each zone in a
sequence.  

In the following algorithm, the region is clipped by zones that are
not visible after the redraw.  A zone can be in one of six states:

\begin{itemize}
\item Unchanged.  This means that the zone has already been drawn in
  the past, and that it hasn't been moved or altered since the last
  time it was drawn.
\item Deleted.  This means that the zone has already been drawn in
  the past, but is no longer supposed to be.  A deleted zone
  might also be marked as moved and/or modified, but ``Deleted'' takes
  precedence.  The region that is needed by the redraw algorithm is
  the region the zone had last time it was drawn, i.e., before
  it was moved or modified.
\item Inserted.  This means that the zone has not been drawn in the
  past, but is supposed to be now.  An inserted zone might also be
  marked as moved and/or modified, but ``Inserted'' takes precedence.
  The region that is needed by the redraw algorithm is the region that
  the zone has after having been moved or modified.
\item Moved and not modified.  This means that the zone has already
  been drawn in the past, but that it has simply changed positions
  since the last time it was drawn.
\item Modified but not moved.  Only a compound zone can be marked as
  modified, indicating that a child zone has been
  inserted, deleted, moved, or modified.
\item Moved and modified.  In this case the zone is treated as
  deleted from its position when last drawn, and inserted at its
  final position. 
\end{itemize}

Applications are responsible for:

\begin{itemize}
\item Marking a zone as ``Modified'' when any of its children is
  either inserted, deleted, moved, or modified.
\item Marking a zone as ``Moved'', whenever it is moved. 
\end{itemize}

The \clim{} redraw algorithm provides the following services, so the
application need not do so:

\begin{itemize}
\item Marking a newly created zone as ``Inserted''. 
\item Automatically detecting that a zone has been deleted, and
  marking it as ``Deleted''. 
\end{itemize}

Only newly created zones can be inserted into a higher-level
zone.  In particular, applications are not allowed to change the
stacking order of zones. 

In the first pass, the redraw algorithm computes the region to be
redrawn.  This is done from the top zone to the bottom zone.  In
each iteration, it modifies the region to be drawn and passes it on to
the next iteration, according to the following cases:

\begin{itemize}
\item If a zone is unchanged, then pass on the region without any
  modification. 
\item If a zone has been deleted, then add its area (i.e, the area
  it occupied when it was last drawn) to the region.
\item If a zone is new (has been inserted since the last redraw),
  then if it is covered by some other visible zone, then add the
  area that is covered to the region.  This is an important
  optimization, because when a new zone is drawn on top, what is
  underneath does not need to be redrawn. 
\item If a zone has been moved (whether also modified or not), then
  in the most general case, treat it as one deleted and one inserted
  zone.
\item If a zone has been modified but not moved, recursively
  traverse the children.
\end{itemize}

In the second pass, the region that has been computed in the first
pass is used to draw the zones from bottom to top.

\begin{itemize}
\item If a zone does not overlap the region, then do nothing
\item If it does overlap the region, and it is an atomic zone,
  request an \emph{redisplay} of the relevant region from the
  application. 
\item If it does overlap the region and it is a compound zone,
  recursively traverse its children.
\end{itemize}

\section{Details of algorithm}

The algorithm for optimal redrawing is divided into two parts.  The
first part computes the region to be redrawn, and the second part
redraws that region.

To compute the region to redraw, the algorithm manages three regions:

\begin{itemize}
\item A region called \texttt{region-to-redraw}, which is the region
  that ultimately becomes the final result of the algorithm.  This
  region grows as the algorithm traverses zones from top to bottom.
  The initial value for this region is \texttt{+nowhere+}.
\item A region called \texttt{visible-region-after} which is the
  region that is visible after the redraw.  This region starts off as
  \texttt{+everywhere+} and may decrease in size as a result of opaque
  zones.
\item A region called
  \texttt{visible-translucent-covering-region-after}, which is a
  region containing potentially translucent zones \emph{after}
  redraw.  This region allows for an important optimization in that
  when a region needs to be redrawn and it is not covered by any
  translucent zones, it can be drawn on top of what is already
  there.  If, however, it has translucent zones on top, the region
  needs to be ``erases'', meaning all zones in that region need to
  be redrawn from bottom to top. 
\end{itemize}

The algorithm to compute the region to redraw thus takes four
arguments: a zone and the three regions indicated above.  It
traverses the zones from top to bottom, and in each step, it
modifies the three regions, and passes on the modified regions to the
next iteration.  A complete description of the algorithm must specify
for each type of zone how the regions are modified. 

For an \emph{opaque} zone, the regions are modified as follows:

\begin{itemize}
\item \texttt{region-to-redraw}.  If the zone has been deleted, then
  add its visible subregion to \texttt{region-to-redraw}.  Otherwise,
  this region stays the same.
\item \texttt{visible-region-after}.  Of the zone has been inserted,
  or is the same, from this region we subtract the region of the
  zone, because of the opacity of the zone.
\item \texttt{visible-translucent-covering-region-after}.  This region
  is treated the same way as the previous one.
\end{itemize}

For a \emph{atomic translucent zone}, the regions are modified as
follows:

\begin{itemize}
\item \texttt{region-to-redraw}.  This is an atomic zone, so it is
  either inserted, deleted, or unchanged.  If it is unchanged,
  this region is not modified.  If it is deleted, the
  visible part of the region of the zone is added to this region.
  If it is inserted, the visible part of the region of the zone that
  is also covered by translucent zones.  The part that is not
  covered by translucent zones can be drawn on top of existing
  pixels without the need to redraw.  Thus,
  we first compute the intersection of the inserted region of the zone
  with \texttt{visible-translucent-covering-region-after}.
\item \texttt{visible-region-after}.  This region does not change for
  translucent zones. 
\item \texttt{visible-translucent-covering-region-after}.  If the
  zone has been inserted or is unchanged, then the visible
  part of the zone is added to this region.  This region does not
  change for a deleted zone.
\end{itemize}

Finally, the complicated case is for a \emph{compound translucent
  zone}.  We would like to avoid scanning the children if possible,
  at the risk of having more zones redrawn at the end.  Individual
  zones will indicate that a minor change has been made to its
  children by marking it modified and that a major change has been
  made by replacing the old zone by a new one, in effect deleting
  the old one and inserting a new one.  We consider a compound zone
  to be relatively densely covered by translucent children, so that
  the entire region of the zone can be passed on as being a
  translucent covering region.

\begin{itemize}
\item \texttt{region-to-redraw}.  If the zone is unchanged, we pass
  this region on unchanged.  If the zone has been inserted or
  deleted, we treat this region in the same way as for an atomic
  translucent zone.  Finally, if zone has been modified, we
  recursively consider the children of this zone.  The initial value
  of this region for the children is the region of the zone after
  redraw intersected with the union of the region of the zone
  before and after redraw.  The result is added to
  \texttt{region-to-redraw} and passed on.
\item \texttt{visible-region-after}.  This region is always passed on
  unchanged as with translucent atomic zones. 
\item \texttt{visible-translucent-covering-region-after}.  Unless the
  zone has been deleted, the visible part of the zone is added to
  this region.
\end{itemize}

\chapter{Output recording}

\section{Introduction}

Applications typically maintain some kind of data structure that is
modified as a result of executing a \clim{} \emph{command object}.  To
generate visible output from such a data structure, the application
will have to produce a hierarchy of zones that \clim{} can draw on
the canvas.  \clim{} facilitates this task by letting the application
programmer use seemingly low-level primitives such as \code{draw-line}
and \code{draw-text} and automatically converting them to zones.
Also, \clim{} maintains a \emph{cursor} indicating the position of
output within the parent zone, making it possible for the
application to use ordinary \cl{} output primitives such as
\code{print} or \code{format}.  Each line of text is automatically
converted to a zone. 

A simple application such as an IRC client or some other application
that generates an increasing amount of output at each iteration of the
command loop, might indicate to \clim{} that the hierarchy of zones
of some pane should not be cleared each time around the command loop,
and that each piece of output should simply be added to the
hierarchy.  Such an application might occasionally explicitly request
that the hierarchy be cleared, but \clim{} will never do it
automatically. 

\section{Incremental redisplay}

Applications can be written with various degrees of performance in
mind.  A very basic application may simply clear the application pane
and traverse the entire application data structure at the end of each
iteration of the command loop and generate fresh output for its entire
data structure.  For instance, a text-editor application might have a
data structure consisting of paragraphs, lines, words, and characters.
Such an application might scan the entire data structure and generate
a hierarchy of zones corresponding to its internal data structure. 

A simple application such as the one above might be improved in terms
of performance by taking advantage of the possibility of \clim{} to
compare two hierarchies of zones, one at the beginning of an
iteration of the command loop, and the other one at the end.  By
a slight modification to the application logic, one might insert a
test for each zone to be generated that will verify if the contents
of the zone is unchanged since the previous iteration of the command
loop.  If this is the case, the entire generation of the output can be
omitted and \clim{} can reuse the existing zone instead.  The
advantage of this technique is that it requires only minor
modifications of the very simple application logic that consists of
scanning the entire data structure each time around the command loop,
and that performance can be quite acceptable, even for fairly large
data structures.  Imagine again the text-editor application above.  In
most cases, a single line in a single paragraph has changed.  The
zones generated by most paragraphs can thus be reused.  While each
paragraph has to be tested, most tests will result in no further
traversal of the paragraph being necessary.  The time spent by the
application is thus linear in the number of top-level data-structure
elements (paragraphs) in most cases.  

A more compound application will manipulate the hierarchy of zones
explicitly.  For instance, a word-processor application might have a
data structure consisting of chapters, sections, paragraphs, words,
and characters.  A complicated incremental page-layout algorithm might
convert this data structure to another one, consisting of pages,
paragraphs, lines, and words.  For performance reasons, the
page-layout algorithm needs to be incremental, so the application
needs to maintain a copy of the resulting data structure and only
update it when necessary.  An application of this degree of complexity
would simply map each element of the resulting data structure (pages,
paragraphs, lines, words) to a \clim{} zone.  At each iteration of
the command loop, such an application can still take care of the
capability of \clim{} to compare two data structures, by generating a
new hierarchy each time around the command loop.  Most of the
top-level zones (corresponding to pages) will be the same, and
within the pages that have changed, most paragraphs will be the same,
etc.  \clim{} is thus capable of minimizing the update of the screen at
a cost that most of the time corresponds to iterating over each
top-level zone. 

\end{document}
