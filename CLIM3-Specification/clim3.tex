\documentclass{report}

\def\cl{Common Lisp}
\def\clim{CLIM~3}
\def\climtwo{CLIM~2}
\def\clos{CLOS}
\def\lisp{Lisp}
\def\zone{zone}
\def\code#1{\texttt{#1}}

\setlength{\parskip}{0.3cm}
\setlength{\parindent}{0cm}

\title{\clim{}\\ A new interface manager for\\ \cl{}}
\author{Robert Strandh}


\begin{document}

\maketitle

\chapter{Preliminaries}

This document is work in progress.  It contains some ideas about the
successor of \climtwo{}, the Common Lisp Interface Manager.  \climtwo{} is in
many respects a very good specification.  We believe, however, that
the reason for many design decisions were related to limitations of
the performance of computers at the time the specification was
written; limitations that are much less severe these days.  

We have attempted to simplify many aspects of the \climtwo{}
specification, often according to the \emph{issues} that are listed in
it.  One major such simplification is that we have merged three
concepts: \emph{sheet}, \emph{output-record} and \emph{design} (to
some degree). 

\chapter{Changes from \climtwo{}}

\section{General}

This section explains the general changes that we consider for \clim{}
compared to \climtwo{}.  Following sections will contain specific changes
with respect to particular features of \climtwo{}.

We intend to act upon one of the ``major issues'' indicated in the
\climtwo{} specification, namely a suggested merge of the \emph{sheet} and
\emph{output record} concepts.  This will greatly simplify the design
of \clim{}.

There are many issues with the \climtwo{} specification.  For
instance, what happens to an output record (which is rectangular
according to the specification) when it is in a pane that has an
arbitrary sheet transformation that does not preserve this shape?  For
\clim{} we want to clarify what happens in such situations, and
eliminate it as a part of the specification if the concept is hard or
impossible to implement. 

Several aspects of the \climtwo{} specification make it hard to
localize applications.  One such aspect is the fact that command-line
names are part of the command table, requiring a different command
table for each language.  We want to clean up such aspects so as to
prepare \clim{} for the possibility of writing applications using
different languages. 

By clarifying the semantics of \emph{zones} (which replace \climtwo{}
\emph{output records}), especially with respect to the exact time when
the effect of manipulating the hierarchy of these objects is visible,
we avoid the almost inevitably quadratic algorithms involved in
manipulating \climtwo{} output records. 

We keep the layout protocol, but clarify when it is invoked.  We
replace space requirements by vertical and horizontal elasticity
functions. 

We eliminate mirrored sheets as an explicit abstraction of \clim{} and
let each backend decide on a case-by-case basis whether a zones should
have a mirror or not.

We eliminate alignment and spacing options to the layout panes and
instead provide a zone type that is very rigid (for spacing) and a
zone type that is very elastic (for alignment).

\section{Regions and Transformations}

In \climtwo{} this is a very general concept.  We will probably keep
these, but the \clim{} equivalent of a \climtwo{} sheet (called a
\emph{zone}) will not admit arbitrary regions and transformations. 

\section{Sheets}

\section{Commands and command tables}

\section{Internationalization}

Define a classes for country, language, printing of numbers, units,
etc, and locale classes that inherit from subclasses of those.

\section{Text styles}

We keep the concept of text styles, but we may remove the concept of
merging text styles.  We add the possibility of naming font families. 
We will specify that text-style-ascent, text-style-descent,
text-style-height, and text-style-width may only be called as part of
the layout protocol, because they are only defined when the zone is
attached to a port. 

\section{Layout protocol}

We guarantee that the layout protocol will only be run when the zone
hierarchy is attached to a port.  Thus, when a text zone is asked to
provide space requirements, then it is safe for it to ask the size of
the text, because the text style then has a mapping to a device font. 

\chapter{Introduction}

All terminology is preliminary.

At the lowest level of abstraction, \clim{} uses a \emph{canvas} which
is an axis-aligned rectangular area of opaque \emph{pixels} supplied by
the underlying windowing system.  Drawing on this canvas means taking
some arbitrary subset of pixels on it, and modifying their color
values in some way.  The result thus depends not only on what was
drawn, but also what was there before.  The \emph{order} in which
drawings are made is thus important.  The canvas uses integer
coordinates.

Applications do not draw directly to the canvas, and in fact \clim{}
does not have any representation of the canvas.  Instead,
\clim{} manages a \emph{hierarchy} of \emph{zones}.  A zone is an
axis-aligned rectangular area.  Each zone manages its own abstract
\emph{drawing plane} which is a potentially infinite plane with its
origin in the upper-left corner of the zone.  The position and size
of a zone are defined with integer coordinates, and the position is
relative to its parent zone.  The effect of drawing a zone is
\emph{clipped} by its parent zone, i.e., a request to draw a zone
is accompanied by a clipping region, and zones are not allowed to
draw outside this region, because if they did, the result would be
incorrect. 

When a hierarchy is attached to a \emph{port} (representing a display
server), the \emph{backend} takes this hierarchy of zones and
\emph{realizes} each zone in the hierarchy in some device-specific
way.  Some backends may choose to create a window for each zone, and
some others may chose to create a single window for the top zone. 

Zones are either \emph{atomic} or \emph{compound}.  An atomic
zone represents an elementary graphics object such as a line, a
rectangle, an ellipse, or an image.  A compound zone contains
a bunch of children organized in a way that depends on the specific
compound zone.  It could be a \cl{} list, a \cl{} two-dimensional
array, or something else.  Each zone has a \emph{position}, a
\emph{size}, and a \emph{depth}.  The position and the depth represent
information relating to the \emph{parent} of the zone.  The depths 
of the children of a compound zone determine the order in which
children are traversed for things like drawing. 

In terms of zone composition operations, zones on the same level
of the hierarchy are composed using the \emph{compose-over} operation,
in the order determined by the depth, and for a compound
zone, the result of the composition of the children is composed with
the parent, which is considered to be a zone with opacity $0$
outside the zone and $1$ inside it.\footnote{Doesn't look right}.

Most zones are not created with exact sizes, because the exact size of
a zone may depend on the backend.  This is in particular the case for
a \emph{text zone} the size of which depends on the \emph{font} used
to render it, and the font is specific to each backend.  Instead, each
zone has a horizontal and a vertical \emph{give}.  A give is an object
that represents the difficulty with which a zone can change its size
in that dimension.  A (somewhat flawed) metaphor would be to liken the
zone to a \emph{spring}, that generates a certain \emph{force} as a
response to an attempt to expand or contract it.  Some zones have
gives assigned at creation time.  Others, such as many compound layout
zones, compute their gives as a function of the gives of their
children.  Yet others, in particular \emph{text} compute their gives
by consulting the port that it is connected to.

Applications can manipulate the zone hierarchy in several different
ways:  

\begin{itemize}
\item They may explicitly insert or delete zones.  In this case
  \clim{} may try to minimize the areas of the canvas that need to be
  redrawn by re-using pixel colors that are known to be the same as
  last time around the command loop.

\item Simpler application might generate new zone hierarchies every
  time around the command loop.  In this case, \clim{} will have to
  redraw the entire contents of the zone.

\item An application may produce a new sequence of children for each
  iteration of the command loop such that some or all of the new zones
  are \emph{the same} as the existing ones.  \clim{} may compare the
  new sequence to the old one, and again minimize redrawing.

\item An application may \emph{move} a zone.  Since the canvas uses
  integer coordinates, \clim{} might then be able to move the pixels
  without requiring the application to generate new output.  This is a
  particularly important optimization when \emph{scrolling} is
  required.  Moving a zone may have no visible effect, if that zone is
  the child of a layout zone that imposes the position of its
  children.
\end{itemize}

\chapter{Optimal redrawing}

\section{Introduction}

The purpose of optimal redrawing is not mainly to touch as few pixels
as possible in the visible area of the screen, even though it can do
that as well.  Instead, the purpose is to simplify applications by
having \clim{} manage a very large number of zones, most of which
are invisible at any point in time.  Imagine for instance a word
processor or an editor for music scores.  Such an application might
produce hundreds of pages of output.  Instead of leaving the burden to
the application writer to determine what part is visible, and how
large the scroll bar should be, it would be good if the application
can produce the entire output, and let \clim{} deal with scrolling and
incremental modifications to the output.  

Such an application might be written to produce a hierarchy of
zones.  At a high level, each page might be a zone.  Each such
page can contain paragraphs or, in the case of a score editor,
\emph{systems}, then lines, words, and perhaps individual characters.
This output is visible through a small viewport that might cover a
single page, or at most a few pages.  The main purpose of the
algorithm presented here is to avoid invoking code to draw parts of
the output that are currently invisible and parts that have not changed
since the previous time.  For instance, after a single modification of
a page of text, most paragraphs might be intact.  The algorithm
described here is able to avoid redrawing such paragraphs. 

In other words, the application writer does not explicitly manage
visibility, and can write the application as if every part of the
output is visible.

The algorithm makes two passes over a hierarchy of zones, the first
one from top to bottom, and the second one from bottom to top.  For
this reason the sequence of zones is probably best represented as a
doubly-linked list.

In the first pass, a region to be redrawn is computed.  This region
starts out as empty and is potentially added to for each zone in a
sequence.  

In the following algorithm, the region is clipped by zones that are
not visible after the redraw.  A zone can be in one of six states:

\begin{itemize}
\item Unchanged.  This means that the zone has already been drawn in
  the past, and that it hasn't been moved or altered since the last
  time it was drawn.
\item Deleted.  This means that the zone has already been drawn in
  the past, but is no longer supposed to be.  A deleted zone
  might also be marked as moved and/or modified, but ``Deleted'' takes
  precedence.  The region that is needed by the redraw algorithm is
  the region the zone had last time it was drawn, i.e., before
  it was moved or modified.
\item Inserted.  This means that the zone has not been drawn in the
  past, but is supposed to be now.  An inserted zone might also be
  marked as moved and/or modified, but ``Inserted'' takes precedence.
  The region that is needed by the redraw algorithm is the region that
  the zone has after having been moved or modified.
\item Moved and not modified.  This means that the zone has already
  been drawn in the past, but that it has simply changed positions
  since the last time it was drawn.
\item Modified but not moved.  Only a compound zone can be marked as
  modified, indicating that a child zone has been
  inserted, deleted, moved, or modified.
\item Moved and modified.  In this case the zone is treated as
  deleted from its position when last drawn, and inserted at its
  final position. 
\end{itemize}

Applications are responsible for:

\begin{itemize}
\item Marking a zone as ``Modified'' when any of its children is
  either inserted, deleted, moved, or modified.
\item Marking a zone as ``Moved'', whenever it is moved. 
\end{itemize}

The CLIM redraw algorithm provides the following services, so the
application need not do so:

\begin{itemize}
\item Marking a newly created zone as ``Inserted''. 
\item Automatically detecting that a zone has been deleted, and
  marking it as ``Deleted''. 
\end{itemize}

Only newly created zones can be inserted into a higher-level
zone.  In particular, applications are not allowed to change the
stacking order of zones. 

In the first pass, the redraw algorithm computes the region to be
redrawn.  This is done from the top zone to the bottom zone.  In
each iteration, it modifies the region to be drawn and passes it on to
the next iteration, according to the following cases:

\begin{itemize}
\item If a zone is unchanged, then pass on the region without any
  modification. 
\item If a zone has been deleted, then add its area (i.e, the area
  it occupied when it was last drawn) to the region.
\item If a zone is new (has been inserted since the last redraw),
  then if it is covered by some other visible zone, then add the
  area that is covered to the region.  This is an important
  optimization, because when a new zone is drawn on top, what is
  underneath does not need to be redrawn. 
\item If a zone has been moved (whether also modified or not), then
  in the most general case, treat it as one deleted and one inserted
  zone.
\item If a zone has been modified but not moved, recursively
  traverse the children.
\end{itemize}

In the second pass, the region that has been computed in the first
pass is used to draw the zones from bottom to top.

\begin{itemize}
\item If a zone does not overlap the region, then do nothing
\item If it does overlap the region, and it is an atomic zone,
  request an \emph{redisplay} of the relevant region from the
  application. 
\item If it does overlap the region and it is a compound zone,
  recursively traverse its children.
\end{itemize}

\section{Details of algorithm}

The algorithm for optimal redrawing is divided into two parts.  The
first part computes the region to be redrawn, and the second part
redraws that region.

To compute the region to redraw, the algorithm manages three regions:

\begin{itemize}
\item A region called \texttt{region-to-redraw}, which is the region
  that ultimately becomes the final result of the algorithm.  This
  region grows as the algorithm traverses zones from top to bottom.
  The initial value for this region is \texttt{+nowhere+}.
\item A region called \texttt{visible-region-after} which is the
  region that is visible after the redraw.  This region starts off as
  \texttt{+everywhere+} and may decrease in size as a result of opaque
  zones.
\item A region called
  \texttt{visible-translucent-covering-region-after}, which is a
  region containing potentially translucent zones \emph{after}
  redraw.  This region allows for an important optimization in that
  when a region needs to be redrawn and it is not covered by any
  translucent zones, it can be drawn on top of what is already
  there.  If, however, it has translucent zones on top, the region
  needs to be ``erases'', meaning all zones in that region need to
  be redrawn from bottom to top. 
\end{itemize}

The algorithm to compute the region to redraw thus takes four
arguments: a zone and the three regions indicated above.  It
traverses the zones from top to bottom, and in each step, it
modifies the three regions, and passes on the modified regions to the
next iteration.  A complete description of the algorithm must specify
for each type of zone how the regions are modified. 

For an \emph{opaque} zone, the regions are modified as follows:

\begin{itemize}
\item \texttt{region-to-redraw}.  If the zone has been deleted, then
  add its visible subregion to \texttt{region-to-redraw}.  Otherwise,
  this region stays the same.
\item \texttt{visible-region-after}.  Of the zone has been inserted,
  or is the same, from this region we subtract the region of the
  zone, because of the opacity of the zone.
\item \texttt{visible-translucent-covering-region-after}.  This region
  is treated the same way as the previous one.
\end{itemize}

For a \emph{atomic translucent zone}, the regions are modified as
follows:

\begin{itemize}
\item \texttt{region-to-redraw}.  This is an atomic zone, so it is
  either inserted, deleted, or unchanged.  If it is unchanged,
  this region is not modified.  If it is deleted, the
  visible part of the region of the zone is added to this region.
  If it is inserted, the visible part of the region of the zone that
  is also covered by translucent zones.  The part that is not
  covered by translucent zones can be drawn on top of existing
  pixels without the need to redraw.  Thus,
  we first compute the intersection of the inserted region of the zone
  with \texttt{visible-translucent-covering-region-after}.
\item \texttt{visible-region-after}.  This region does not change for
  translucent zones. 
\item \texttt{visible-translucent-covering-region-after}.  If the
  zone has been inserted or is unchanged, then the visible
  part of the zone is added to this region.  This region does not
  change for a deleted zone.
\end{itemize}

Finally, the complicated case is for a \emph{compound translucent
  zone}.  We would like to avoid scanning the children if possible,
  at the risk of having more zones redrawn at the end.  Individual
  zones will indicate that a minor change has been made to its
  children by marking it modified and that a major change has been
  made by replacing the old zone by a new one, in effect deleting
  the old one and inserting a new one.  We consider a compound zone
  to be relatively densely covered by translucent children, so that
  the entire region of the zone can be passed on as being a
  translucent covering region.

\begin{itemize}
\item \texttt{region-to-redraw}.  If the zone is unchanged, we pass
  this region on unchanged.  If the zone has been inserted or
  deleted, we treat this region in the same way as for an atomic
  translucent zone.  Finally, if zone has been modified, we
  recursively consider the children of this zone.  The initial value
  of this region for the children is the region of the zone after
  redraw intersected with the union of the region of the zone
  before and after redraw.  The result is added to
  \texttt{region-to-redraw} and passed on.
\item \texttt{visible-region-after}.  This region is always passed on
  unchanged as with translucent atomic zones. 
\item \texttt{visible-translucent-covering-region-after}.  Unless the
  zone has been deleted, the visible part of the zone is added to
  this region.
\end{itemize}

\chapter{Output recording}

\section{Introduction}

Applications typically maintain some kind of data structure that is
modified as a result of executing a \clim{} \emph{command object}.  To
generate visible output from such a data structure, the application
will have to produce a hierarchy of zones that \clim{} can draw on
the canvas.  \clim{} facilitates this task by letting the application
programmer use seemingly low-level primitives such as \code{draw-line}
and \code{draw-text} and automatically converting them to zones.
Also, \clim{} maintains a \emph{cursor} indicating the position of
output within the parent zone, making it possible for the
application to use ordinary \cl{} output primitives such as
\code{print} or \code{format}.  Each line of text is automatically
converted to a zone. 

A simple application such as an IRC client or some other application
that generates an increasing amount of output at each iteration of the
command loop, might indicate to \clim{} that the hierarchy of zones
of some pane should not be cleared each time around the command loop,
and that each piece of output should simply be added to the
hierarchy.  Such an application might occasionally explicitly request
that the hierarchy be cleared, but \clim{} will never do it
automatically. 

\section{Incremental redisplay}

Applications can be written with various degrees of performance in
mind.  A very basic application may simply clear the application pane
and traverse the entire application data structure at the end of each
iteration of the command loop and generate fresh output for its entire
data structure.  For instance, a text-editor application might have a
data structure consisting of paragraphs, lines, words, and characters.
Such an application might scan the entire data structure and generate
a hierarchy of zones corresponding to its internal data structure. 

A simple application such as the one above might be improved in terms
of performance by taking advantage of the possibility of \clim{} to
compare two hierarchies of zones, one at the beginning of an
iteration of the command loop, and the other one at the end.  By
a slight modification to the application logic, one might insert a
test for each zone to be generated that will verify if the contents
of the zone is unchanged since the previous iteration of the command
loop.  If this is the case, the entire generation of the output can be
omitted and \clim{} can reuse the existing zone instead.  The
advantage of this technique is that it requires only minor
modifications of the very simple application logic that consists of
scanning the entire data structure each time around the command loop,
and that performance can be quite acceptable, even for fairly large
data structures.  Imagine again the text-editor application above.  In
most cases, a single line in a single paragraph has changed.  The
zones generated by most paragraphs can thus be reused.  While each
paragraph has to be tested, most tests will result in no further
traversal of the paragraph being necessary.  The time spent by the
application is thus linear in the number of top-level data-structure
elements (paragraphs) in most cases.  

A more compound application will manipulate the hierarchy of zones
explicitly.  For instance, a word-processor application might have a
data structure consisting of chapters, sections, paragraphs, words,
and characters.  A complicated incremental page-layout algorithm might
convert this data structure to another one, consisting of pages,
paragraphs, lines, and words.  For performance reasons, the
page-layout algorithm needs to be incremental, so the application
needs to maintain a copy of the resulting data structure and only
update it when necessary.  An application of this degree of complexity
would simply map each element of the resulting data structure (pages,
paragraphs, lines, words) to a \clim{} zone.  At each iteration of
the command loop, such an application can still take care of the
capability of \clim{} to compare two data structures, by generating a
new hierarchy each time around the command loop.  Most of the
top-level zones (corresponding to pages) will be the same, and
within the pages that have changed, most paragraphs will be the same,
etc.  \clim{} is thus capable of minimizing the update of the screen at
a cost that most of the time corresponds to iterating over each
top-level zone. 

\chapter{Command loop}

\clim{} maintains a \emph{command loop} as follows:

\begin{itemize}
\item Acquire a \emph{command object}.
\item Acquire the arguments of the command object.
\item Execute the command object on the arguments.
\item Call \code{redisplay} on the top zone.  The result of calling
  \code{redisplay} might be a new zone or the same zone, modified
  or unchanged.  The behavior of redisplay on a particular zone
  depends on the exact subclass of the zone.
\item Update the visible area of the screen according to the new
  zone hierarchy.
\end{itemize}

\chapter{Zone protocls}

\section{Purpose}

The purpose of the zone protocols is twofold:

\begin{itemize}
\item The main purpose is to make certain operations simple and
  transparent to applications.  See below for details.
\item The secondary purpose is to optimize rendering so that even for
  very large data sets, the response time is reasonable.
\end{itemize}

Applications should be able to manipulate both connected and
disconnected zone hierarchies in a painless way.  Operations available
to an application are:

\begin{itemize}
\item An application should be able to move a zone by setting its
  horizontal and vertical positions.  The result of the operation
  should be immediately visible after the next iteration of the event
  loop.  Though of course, it is possible that the zone being moved by
  the application is again moved by its parent zone, if the parent
  zone is a layout zone that imposes a position of its children.  In
  that case, there will be no visible effect.
\item An application should be able to modify the depth of a zone.  
\item An application should be able to change the children of a
  compound zone.
\end{itemize}

Notice that the effects of the modifications are synchronized with the
event loop, and that the event loop is responsible for the ultimate
rendering of the zone hierarchy.  Therefore, an application can make
multiple changes to the zone hierarchy as a result of a single event,
and only the final result of those changes will be rendered.  

Let us examine the consequences of these operations in greater
detail. 

\subsection{Moving a zone}

If the zone is the root zone, then we might want to ask the display
server to move the corresponding window. 

If the zone is the child of bboard zone, then we need to render it in
a different place next time. 

If the zone is the child of a scroller zone, the scrollbar will have
to be rendered differently next time. 

If the zone if part of a layout zone that imposes positions of the
child, then moving it will have no effect. 

\subsection{Modifying the depth of a zone}

If the zone is a root zone, we might ask the window manager to raise
or bury the corresponding window, but we might do nothing. 

Otherwise, the sibling zones will be rendered in a different order
next time.

\subsection{Changing the children of a zone}

If the zone is a bboard zone, new children must have valid gives so
that we can compute their natural sizes before rendering

If the zone is a scroller zone, we must make sure the child has a
valid give so that we can compute its natural size before rendering.

If the zone is the child of a layout zone that computes its gives from
the gives of its children, then the parent must have its gives
invalidated, so that they are recomputed next time it is rendered.
This invalidation must propagate up the hierarchy until a zone is
reached that does not take child gives into account. 

\section{Zone geometry protocol}

\subsection{Generic functions}

\subsubsection{Generic function \texttt{hpos}}

Return the current horizontal position of the zone relative to its
parent.  

If the zone is the root zone and it is connected to some display
server, then depending on the display server, this value may or
may not reflect the position of the corresponding top-level
window on the display. 

\subsubsection{Generic function \texttt{(setf hpos)}}

Set the current horizontal position of the zone relative to its
parent.  

Calling this function is the normal way of setting the position of
a zone that is the child of a layout zone that does not impose the
position of its children, such as a bboard zone or a scroller
zone.

Setting the position of a zone may not have the effect that an
application expects.  If the zone is the child of a layout zone
that imposes the position of its children, then the change will be
undone before the next time around the event loop, so that no
visible effect can be detected.  

If the zone is the root zone and it is connected to some display
server, then depending on the display server, this value may or
may not affect the position of the corresponding top-level window
on the display.

Calling this function triggers the geometry-change protocol,
informing the parent that a change has taken place.  

\subsubsection{Generic function \texttt{set-hpos}}

Set the current horizontal position of the zone relative to its
parent, without triggering the geometry-change protocol.

This function is similar to \texttt{(setf hpos)}, with the difference
that it does not trigger the geometry-change protocol.  It is used
exclusively by internal protocols to avoid infinite recursions when a
parent needs to set the position of a child as a result of some
previous change.

\subsubsection{Generic function \texttt{vpos}}

Return the current vertical position of the zone relative to its
parent.  

If the zone is the root zone and it is connected to some display
server, then depending on the display server, this value may or
may not reflect the position of the corresponding top-level window
on the display.

\subsubsection{Generic function \texttt{(setf vpos)}}

Set the current vertical position of the zone relative to its
parent.

Calling this function is the normal way of setting the position of
a zone that is the child of a layout zone that does not impose the
position of its children, such as a bboard zone or a scroller
zone.

Setting the position of a zone may not have the effect that an
application expects.  If the zone is the child of a layout zone
that imposes the position of its children, then the change will be
undone before the next time around the event loop, so that no
visible effect can be detected.  

If the zone is the root zone and it is connected to some display
server, then depending on the display server, this value may or
may not affect the position of the corresponding top-level window
on the display.

Calling this function triggers the geometry-change protocol,
informing the parent that a change has taken place.  

\subsubsection{Generic function \texttt{set-vpos}}

Set the current vertical position of the zone relative to its
parent, without triggering the geometry-change protocol.

This function is similar to \texttt{(setf vpos)}, with the difference
that it does not trigger the geometry-change protocol.  It is used
exclusively by internal protocols to avoid infinite recursions when a
parent needs to set the position of a child as a result of some
previous change.

\subsubsection{Generic function \texttt{width}}

Return the current width of the zone.  

If the zone is the root zone and it is connected to some display
server, then depending on the display server, this value may or
may not reflect the width of the corresponding top-level window.

\subsubsection{Generic function \texttt{(setf width)}}

Set the current width of the zone.

Calling this function is the normal way of setting the width of a
zone that is the child of a layout zone that does not impose the
size of its children, such as a bboard zone or a scroller zone.

Setting the position of a zone may not have the effect that an
application expects.  If the zone is the child of a layout zone
that imposes the size of its children, then the change will be
undone before the next time around the event loop, so that no
visible effect can be detected.

If the zone is the root zone and it is connected to some display
server, then depending on the display server, this value may or
may not affect the width of the corresponding top-level window
on the display.

Calling this function triggers the geometry-change protocol,
informing the parent that a change has taken place.  

\subsubsection{Generic function \texttt{set-width}}

Set the current width of the zone relative to its parent, without
triggering the geometry-change protocol.

This function is similar to \texttt{(setf width)}, with the difference
that it does not trigger the geometry-change protocol.  It is used
exclusively by internal protocols to avoid infinite recursions when a
parent needs to set the width of a child as a result of some previous
change.

\subsubsection{Generic function \texttt{height}}

Return the current height of the zone.

If the zone is the root zone and it is connected to some display
server, then depending on the display server, this value may or
may not reflect the height of the corresponding top-level window.

\subsubsection{Generic function \texttt{(setf height)}}

Set the current height of the zone.

Calling this function is the normal way of setting the height of a
zone that is the child of a layout zone that does not impose the
size of its children, such as a bboard zone or a scroller zone.

Setting the position of a zone may not have the effect that an
application expects.  If the zone is the child of a layout zone
that imposes the size of its children, then the change will be
undone before the next time around the event loop, so that no
visible effect can be detected.

If the zone is the root zone and it is connected to some display
server, then depending on the display server, this value may or
may not affect the height of the corresponding top-level window on
the display.

Calling this function triggers the geometry-change protocol,
informing the parent that a change has taken place.

\subsubsection{Generic function \texttt{set-height}}

Set the current height of the zone relative to its parent, without
triggering the geometry-change protocol.

This function is similar to \texttt{(setf height)}, with the
difference that it does not trigger the geometry-change protocol.  It
is used exclusively by internal protocols to avoid infinite recursions
when a parent needs to set the height of a child as a result of some
previous change.

\subsubsection{Generic function \texttt{depth}}


\subsubsection{Generic function \texttt{(setf depth)}}

\subsection{Classes}

\subsubsection{Class \texttt{zone}}

The class \texttt{zone} is the base class for all zones. 


\section{Zone genealogy protocol}

\subsection{Generic functions}

\subsubsection{Generic function \texttt{parent}}

Return the current parent of the zone. 

The parent may be another zone, in which case the zone is a child of
that zone, or it may be a client (typically a port), in which case the
zone is the root zone of a hierarchy connected to that client, or it
may be nil, in which case, this zone is the root zone of a hierarchy
not currently connected to any client.

\subsubsection{Generic function \texttt{(setf parent)}}

Set the parent of a zone.

This generic function is part of the internal zone protocols.  It
should not be used directly by applications.  It is called indirectly
as a result of connecting the zone to a client, or as a result of
adding or removing the zone as a child of some other zone by calling
\texttt{(setf children)}.

\subsubsection{Generic function \texttt{children}}

This generic function returns the children of a compound zone.  The
representation of the return value depends on the subclass of
\texttt{compound-zone}.  It could be a list, a vector, a 2-D array, or
something else.

\subsubsection{Generic function \texttt{(setf children)}}

This generic function sets the children of a compound zone.  The
acceptable representation of the children depends on the subclass of
\texttt{compound-zone}.  It could be a list, a vector, a 2-D array, or
something else.  However, the representation is consistent with what
is returned by the \texttt{children} generic function, so that if a list is
returned by that generic function, then a list is acceptable to this
one too.  In particular, it is acceptable to call this function with
the exact same value as was return by a call to \texttt{children}.

There are \texttt{:around} methods on this function (see below).  One
is specialized for \texttt{at-most-one-child-mixin}, and the other for
\texttt{any-number-of-children-mixin}, both subclasses of
\texttt{compound-zone}.  These \texttt{:around} methods always call
the primary methods, but they also do some extra work such as error
checking, setting the parent of every new child, removing the parent
of every removed child, and client notification.  The \texttt{:around}
method calls \texttt{children}, which has as a consequence that in
order to use \texttt{(setf children)} the corresponding slot must be
bound.

There is one \texttt{:after} method specialized for
\texttt{compound-zone} that calls

\subsubsection{generic function \texttt{map-over-children}}

the first argument is a function of a single argument.  the second
argument is a zone.  this function calls the function given as the
first argument on each child of the zone given as a second argument.  

\subsubsection{generic function \texttt{map-over-children-top-to-bottom}}

the first argument is a function of a single argument.  the second
argument is a zone.  this function calls the function given as the
first argument on each child of the zone given as a second argument.  

\subsubsection{generic function \texttt{map-over-children-bottom-to-top}}

The first argument is a function of a single argument.  The second
argument is a zone.  This function calls the function given as the
first argument on each child of the zone given as a second argument.  

\subsection{Classes}

\subsubsection{Class \texttt{atomic-zone}}

\subsubsection{Class \texttt{compound-zone}}

\subsubsection{Class \texttt{compound-simple-zone}}

\subsubsection{Class \texttt{compound-sequence-zone}}

\subsubsection{Class \texttt{compound-matrix-zone}}

\subsubsection{Class \texttt{at-most-one-child-mixin}}

\subsubsection{Class \texttt{any-number-of-children-mixin}}


\section{Gives change protocol}

The gives change protocol is divided into four functions for maximum
flexibility to client code, three of them generic, and one is an
ordinary function.

\subsection{Generic functions and methods}

\subsubsection{Generic function \texttt{gives-valid-p}}
\label{generic-function-gives-valid-p}

This function returns true if and only if the gives of the zone are
valid.  

For zones with gives that can not be invalidated, such as bboard
zones, scroller zones, and atomic zones with gives that do not depend
on a client, this function always returns \emph{true}.

The methods of this function are paired up with methods for
\texttt{mark-gives-invalid} so that they both use the same mechanism. 

This function should return \emph{false} after a call has been made to
\texttt{mark-gives-invalid}, and should return \emph{true} after a
call has been made to \texttt{compute-gives}.  

A method specialized for \texttt{dependent-gives-mixin} is supplied
that returns \emph{true} of and only if both the \texttt{vgive} and
the \texttt{hgive} of the zone are \texttt{nil}

A method specialized for \texttt{hdependent-gives-mixin} is supplied
that returns \emph{true} if and only if the \texttt{hgive} of the zone
is \texttt{nil}.

A method specialized for \texttt{vdependent-gives-mixin} is supplied
that returns \emph{true} if and only if the \texttt{vgive} of the zone
is \texttt{nil}.

A method specialized for \texttt{independent-gives-mixin} is supplied
that always returns \emph{true}. 

\subsubsection{Generic function \texttt{mark-gives-invalid}}
\label{generic-function-mark-gives-invalid}

This function marks the zone as having invalid gives.  

For zones with gives that can not be invalidated, such as bboard
zones, scroller zones, and atomic zones with gives that do not depend
on a client, this function signals an error.

Different subclasses of \texttt{zone} do this differently.  Some set
both the hgive and the vgive to \texttt{nil}.  Some others set one but
not the other.  Some may use a completely different mechanism.

The methods of this function are paired up with methods for
\texttt{gives-invalid-p} so that they both use the same mechanism.

A method specialized for \texttt{dependent-gives-mixin} is supplied
that sets both the \texttt{vgive} and the \texttt{hgive} of the zone
to \texttt{nil}

A method specialized for \texttt{hdependent-gives-mixin} is supplied
that sets the \texttt{hgive} of the zone to \texttt{nil}.

A method specialized for \texttt{vdependent-gives-mixin} is supplied
that sets the \texttt{vgive} of the zone to \texttt{nil}.

A method specialized for \texttt{independent-gives-mixin} is supplied
that signals an error.

\subsubsection{Generic function \texttt{notify-child-gives-invalid}}
\label{generic-function-notify-child-gives-invalid}

This function is called on a child and a parent when the gives of the
child are invalidated for some reason (see the function
\texttt{invalidate-gives}).  Methods on this generic function
specialized to parent zones (the second argument) whose gives depend
on the gives of its children must call \texttt{invalidate-gives} with
the parent as an argument.

Two default methods are supplied.  The first default method is
specialized on a \texttt{null} parent and it does nothing.  This way,
a zone and its parent are always valid arguments to this function,
even though the zone is disconnected.  The second default method is
specialized on a parent of type \texttt{zone} and it signals an error.
By doing it this way, we compel zones to make an explicit choice
concerning the action of this function.

Other methods are supplied for certain mixin classes.  For the mixin
classes \texttt{dependent-gives-mixin},
\texttt{hdependent-gives-mixin}, and \texttt{vdependent-gives-mixin},
a method is supplied that calls \texttt{invalidate-gives} with the
parent as an argument, as stipulated above.  For the class
\texttt{independent-gives-mixin}, a method is supplied that does
nothing.

\subsubsection{Function \texttt{invalidate-gives}}

This function is used to indicate that the gives of some zone are no
longer valid.  The reason for that could be that the gives depend on
the contents and the contents changed, or that the gives of the zone
depend on it being connected to some client, and it got disconnected.

If the gives of the zone are already invalid, i.e.,
\texttt{gives-valid-p} returns \emph{false}, then this function does
nothing.  Otherwise, it marks them invalid by calling
\texttt{mark-gives-invalid} and calls the function
\texttt{notify-child-gives-invalid} with the zone and its parent.

\section{Zone layout protocol}

The zone layout protocol is designed so that if the zone hierarchy is
appropriately designed, then layout can be done incrementally for good
performance. 

In any hierarchy of zones, some zones may have valid gives and some
zones may have invalid gives.  Atomic zones whose gives do not depend
on any client are always valid.  Atomic zones whose gives depend on
some client may or may not be valid.  If the zone hierarchy is not
connected to a client, they are invalid. 

A compound zone whose gives depend on the gives of its children will
have invalid gives if any of the children has invalid gives.  We
maintain this invariant by using the gives change protocol.  Thus, the
only case where a (compound) zone can have valid gives even though
some child has invalid gives is when that zone is such that its gives
are independent of the gives of the children.  In particular, this is
the case for scroller zones and bboard zones.

When a zone is rendered, its position and size must be known.  In
addition, we require that a zone that is rendered also have valid
gives, even though this is not strictly necessary.

The size and sometimes the position of a zone are set by the parent.
If the parent is a port, then the port must set these parameters
before rendering the zone.  Sometimes, when a zone is rendered, it is
possible that its children do not have the correct position and size.
For instance, if the position of a child of a hbox zone is modified by
the application, then it is likely wrong, so it must be fixed before
the hbox zone can be rendered.  Similarly, if the gives of a child of
a bbox zone have changed, then the natural size of that child is very
likely wrong, so it must be fixed before the bbox zone can be
rendered.

When the position or the gives of a zone change, we want to delay the
fixes until the parent zone must be rendered.  We do this by
maintaining a flag in compound zones that indicate whether the child
geometries are valid or not.  

\subsection{Generic functions}

\subsection{Classes}

\subsubsection{Class \texttt{dependent-gives-mixin}}
\subsubsection{Class \texttt{hdependent-gives-mixin}}
\subsubsection{Class \texttt{vdependent-gives-mixin}}
\subsubsection{Class \texttt{independent-gives-mixin}}

\section{Application frame}

An application frame is a layout zone with a small number of fixed
layouts of sub-zones (we don't call them child zones because they
are not the direct children of the application frame.  Selecting a
particular layout has the effect of creating child zones of the
application frame with positions and sizes that are determined by the
layout, and each child contains a sub-zone.

\section{Table zone}

\section{Simple application zone}

This is a zone that executes a display function each time around the
command loop in order to generate a complete hierarchy of zones.

\section{Incremental application zone}

This is a zone that is able to compare existing child zones with
new ones, and that will recursively generate zones only if a child
is new. 

\chapter{Comparing two sequences of child zones}

Initialize \code{before} and \code{after} to the beginning of the
sequence of children \emph{before} and \emph{after} redisplay
respectively.  If \code{before} is empty, then all remaining children
on \code{after} are inserted.  If \code{after} is empty, then all
remaining children on \code{before} are deleted.  Otherwise (neither
\code{before} nor \code{after} is empty), if the first zone on
\code{after} is new, then it has been inserted; advance \code{after}.
If not, the first zone  on \code{after} is also in the \code{before}
sequence.  In that case, if it is also the first element of
\code{before}, then it is either modified or unchanged according to
the flag; advance both \code{before} and \code{after}.  The last case
is when the first element of \code{after} is not the same as the first
element of \code{before}.  Then the first element of \code{before} has
been deleted; advance \code{before}. 


\end{document}
